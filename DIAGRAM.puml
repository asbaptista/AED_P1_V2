@startuml
skinparam classAttributeIconSize 0

interface Area {
  +getName(): String
  +addService(Service s): void
  +getService(String name): Service
  +addStudent(Student s): void
  +getStudent(String name): Student
  +listAllStudents(): Iterator<Student>
  +getRankedServices(): Iterator<Service>
}

class AreaImpl implements Area {
  -name: String
  -topLat, bottomLat, leftLong, rightLong: long
  -students: StudentCollection
  -services: ServiceCollection
  +getStudent(String name): Student
  +getService(String name): Service
  +listAllStudents(): Iterator<Student>
  +getRankedServices(): Iterator<Service>
}

interface StudentCollection {
  +addStudent(Student s): void
  +removeStudent(String name): void
  +findByName(String name): Student
  +listAllStudents(): Iterator<Student>
  +listStudentsByCountry(String country): Iterator<Student>
}

class StudentsCollectionImpl implements StudentCollection {
  -studentsByName: Map<String, Student>
  -studentsByInsertion: TwoWayList<Student>
  -studentsByNameSorted: SortedMap<String, Student>
  +addStudent(Student s): void
  +removeStudent(String name): void
  +findByName(String name): Student
  +listAllStudents(): Iterator<Student>
  +listStudentsByCountry(String country): Iterator<Student>
}

interface ServiceCollection {
  +add(Service s): void
  +findByName(String name): Service
  +listServices(): Iterator<Service>
  +getServicesByStars(): Iterator<Service>
  +updateRankingByStars(Service s): void
}

class ServicesCollectionImpl implements ServiceCollection {
  -servicesByName: Map<String, Service>
  -servicesByInsertion: TwoWayList<Service>
  -rankingByStars: SortedList<Service>
  +add(Service s): void
  +findByName(String name): Service
  +listServices(): Iterator<Service>
  +getServicesByStars(): Iterator<Service>
  +updateRankingByStars(Service s): void
}

interface Student {
  +getName(): String
  +getCountry(): String
  +goToLocation(Service s): void
  +moveHome(Lodging newHome): void
  +findMostRelevant(Iterator<Service> services): Service
}

abstract class StudentAbs implements Student {
  #name: String
  #country: String
  #home: Lodging
  #current: Service
  #visitedServices: TwoWayList<Service>
}

interface Service {
  +getName(): String
  +getLat(): long
  +getLon(): long
  +getPrice(): int
  +getAvgStar(): int
  +addReview(int rating, String comment): void
  +hasEvaluationWithTag(String tag): boolean
}

abstract class ServiceAbs implements Service {
  #name: String
  #lat, lon: long
  #price: int
  #avgStar: double
  #nEval: int
  #evaluations: TwoWayList<Evaluation>
}

interface Lodging extends Service {
  +addOccupant(Student s): void
  +removeOccupant(Student s): void
  +getOccupantsIterator(): TwoWayIterator<Student>
}

class LodgingImpl extends ServiceAbs implements Lodging {
  -occupants: TwoWayList<Student>
  +addOccupant(Student s): void
  +removeOccupant(Student s): void
  +getOccupantsIterator(): TwoWayIterator<Student>
}

interface Eating extends Service {
  +addOccupant(Student s): void
  +removeOccupant(Student s): void
  +getOccupantsIterator(): TwoWayIterator<Student>
}

class EatingImpl extends ServiceAbs implements Eating {
  -occupants: TwoWayList<Student>
  +addOccupant(Student s): void
  +removeOccupant(Student s): void
  +getOccupantsIterator(): TwoWayIterator<Student>
}

class BookishImpl extends StudentAbs
class OutgoingImpl extends StudentAbs
class ThriftyImpl extends StudentAbs

class LeisureImpl extends ServiceAbs

AreaImpl o-- "1" StudentCollection
AreaImpl o-- "1" ServiceCollection

StudentsCollectionImpl ..> Student
ServicesCollectionImpl ..> Service

StudentAbs <|-- BookishImpl
StudentAbs <|-- OutgoingImpl
StudentAbs <|-- ThriftyImpl

ServiceAbs <|-- LodgingImpl
ServiceAbs <|-- EatingImpl
ServiceAbs <|-- LeisureImpl

StudentAbs o-- "1" Service : current
StudentAbs o-- "1" Lodging : home
StudentAbs o-- "0..*" Service : visitedServices

EatingImpl o-- "0..*" Student : occupants
LodgingImpl o-- "0..*" Student : occupants

note right of StudentsCollectionImpl
  **Justificação (Fase 2):**
  - **studentsByName (Map):** Usa `HashTable` para pesquisa $O(1)$ por nome.
  - **studentsByNameSorted (SortedMap):** Usa `AVLSortedMap` para `students all` ($O(\log N)$).
  - **studentsByInsertion (TwoWayList):** Usa `DoublyLinkedList` para `students <country>` ($O(1)$ `addLast`).
end note

note right of ServicesCollectionImpl
  **Justificação (Fase 2):**
  - **servicesByName (Map):** Usa `HashTable` para pesquisa $O(1)$ por nome.
  - **servicesByInsertion (TwoWayList):** Usa `DoublyLinkedList` para `services` ($O(1)$ `addLast`).
  - **rankingByStars (SortedList):** Usa `SortedDoublyLinkedList` para `ranking`
    (mantido da Fase 1 para garantir o critério de desempate $O(N)$).
end note

@enduml